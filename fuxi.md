![image-20200627110755525](C:\Users\qiaoba\AppData\Roaming\Typora\typora-user-images\image-20200627110755525.png)

### 一 排序

#### 1 内部排序

​      排序过程完全在内存中进行

##### 1.1插入类排序

- 直接插入排序
  - 平均时间复杂度O(n^2)
  - 空间复杂度O(1)

#### 2 外部排序

​      排序过程需要借助外部存储设备才能完成

### 二、HTML

#### 1、HTML文档的基本结构包含哪几个元素？

​          DOCTYPE、html、head、body

#### 2 HTML和HTML5的区别

- 旧版本的HTML比较依赖浏览器的插件，例如播放视频需要安装Flash
- 由于HTML5不在基于SGML，所以文档声明类型（DOCTYPE）只有一种
- HTML5消除了过时或冗余的元素，例如font、center
- HTML5新增了许多语义化的元素（例如article、header）和新功能（例如video、canvas等），提供更好的跨平台支持
- HTML5制定了新的全局属性和元素属性，全局属性有draggable、contenteditable等,元素属性有accept、placeholder

#### 3 浏览器渲染模式

- 怪异模式(Quirks mode)
  - 主要为了兼容早期的浏览器
- 接近标准模式（Almost standards mode）
- 标准模式（Standards mode）

#### 4 HTML实体

- 为了能在HTML文档中，正确显示某些特殊字符
- 实体的定义方式
  - 名称 ：  &name
  - 十进制： & #（数字）
  - 十六进制： &#xhex

- 笔试题：HTML实体的应用场景有哪些？
  
- 如果要在HTML文档中显示特殊字符（例如"<"、“>”等），那么就可以使用HTML实体。HTML实体还能预防XSS(跨站脚本攻击)。XSS通常会将脚本代码注入到HTML文档中，在解析执行。但使用了HTML实体后，就可以让相关代码只打印，而不执行。
  
- meta元素可以定义文档的哪些元数据？

  - 声明HTML文档内容所用的字符编码

  - 完善文档描述信息，让搜索引擎更容易解析索引，提升SEO

  - 适配移动设备，使页面在各种尺寸的屏幕中显示正确

  - 指定首选样式表、执行重载或重定向

    

####  5 javascript indexOf()方法

*indexOf*() 方法可返回某个指定的字符串值在字符串中首次出现的位置。

#### 6、vue双向 绑定

讲的比较细https://juejin.im/post/6844903616046710791

是通过数据劫持结合发布者-订阅者的方式来实现

vue通过Object.defineProperty()来实现数据劫持

Object.defineProperty( )是用来做什么的？它可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，get和set



#### 7 vue生命周期

Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。

![](https://upload-images.jianshu.io/upload_images/11370083-f279314aef6741db.jpg?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![image-20200826155140005](C:\Users\qiaoba\AppData\Roaming\Typora\typora-user-images\image-20200826155140005.png)

![image-20200831150220715](C:\Users\qiaoba\AppData\Roaming\Typora\typora-user-images\image-20200831150220715.png)

#### 8 webworker

WebWorker是H5中新增的API，我们使用这个API可以轻松的创建后台线程，webworker常用于执行那些耗费事件较长的逻辑计算或者大量循环，避免页面假死的发生。

webworker能为我们做什么：
 1、加载一个JS文件，此文件用来进行大量计算，而不挂起主进程，通过postmessage，onmessage方法通信

2、使用importScript(url)加载其他的js文件

3、可以使用js的核心对象和部分浏览器属性

局限性：
 1、不能跨域加载js

2、worker内不能访问dom，如需使用jquery，可加载jqnodom（链接：[https://pan.baidu.com/s/1h-AC0PyM4EdXaZ68NPoCYw](https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F1h-AC0PyM4EdXaZ68NPoCYw)  提取码：0qou ）插件使用jquery调用

3、加载数据效率没有ajax高

#### 9 跨域

https://blog.csdn.net/qq_38128179/article/details/84956552

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。

核心思想：网页通过添加一个`<script>元素`，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。

- CORS 是跨域资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。

  **1、普通跨域请求：只需服务器端设置Access-Control-Allow-Origin**

  2、带cookie跨域请求：前后端都需要进行设置

#### 10 变量提升

#### 11 变量的提升

　　当浏览器开辟出提供代码执行后的栈内存后，代码并没自上而下的立即开始执行，而是继续做了一些事情

　　 1 把当前作用域中所有带 var / functiong关键字的进行了提前的声明和定义，这称为js的变量提升机制

　　　其中，使用var　声明的z只是提前声明，并没有进行赋值，没有赋值，默认值为 undefined

　     使用functiond的不仅声明了，而且还进行了定义 ，让变量和某个值进行关联。

#### 12 http1.0 1.1 2.0

**三、HTTP1.0和HTTP1.1的一些区别**

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

    

**四、HTTPS与HTTP的一些区别**

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。

https://www.cnblogs.com/heluan/p/8620312.html

![image-20200826220438649](C:\Users\qiaoba\AppData\Roaming\Typora\typora-user-images\image-20200826220438649.png)

#### 13、MVVM

  说到vue的双向绑定首先联系到的就是MVVM(Model-View-ViewModel)模式了，如下图所示，当试图发生改变的时候传递给VM,再让数据得到更新，当数据发生改变的时候传给VM,使得试图发生改变；

  MVVM模式是通过以下三个核心组件组成，每个都有它自己独特的角色：

​    **Model** - 包含了业务和验证逻辑的数据模型

​    **View** - 定义屏幕中View的结构，布局和外观

​    **ViewModel** - 扮演“View”和“Model”之间的使者，帮忙处理 **View** 的全部业务逻辑

![img](https://upload-images.jianshu.io/upload_images/15932532-2b985ed5ebaed386.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

![img](https://upload-images.jianshu.io/upload_images/15932532-72b351faa6778ae5.png?imageMogr2/auto-orient/strip|imageView2/2/w/638/format/webp)

#### 14、闭包

闭包就是能够读取其他函数内部变量的函数。

- 闭包的优点
  - 个是前面提到的可以读取函数内部的变量，
  - 另一个就是让这些变量的值始终保持在内存中

- 闭包的应用场景
  - **采用函数引用方式的setTimeout调用**

```
function func(param) {
    return function() {
        alert(param);
    }
}
var f = func(1)
setTimeout(f, 1000);
```

- 使用闭包的注意点
  - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
  - 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值

<font color="red">闭包中的基本数据类型变量不保存在栈内存中，而是保存在堆内存中。</font>

#### 15 let const var

-  let
  - let声明的变量不存在变量提升的问题
  -  let声明的变量，存在<font color="red">块级作用域</font>
  - let不允许在同一作用域内重复声明同一个变量
  - let和const都存在暂时性死区，都必须遵守<font color="red"> "先声明，后使用"的规则</font>

- const
  - const用来声明一个常量，一旦声明其值不可更改  所以const在声明的时候必须要初始化，不能先声明再初始化否则会报错。
  - const声明的变量只在块级作用域内有效。
  - const声明的变量存在暂时性死区。
  - const在同一个作用域内不可重复声明变量
  - 但是用const声明的对象的属性是可以更改的，因为const实质上保证的并不是变量的值不得改动，而是变量指向的内存地址的值不得改动。对于简单类型数据，值就保存在变量指向的内存地址中，相当于常量。而对于复合型的数据，变量指向的是内存地址保存的是一个指针。const只能保证指针是不可以被更改，但指针指向的数据结构是可以被改变的。

- var 
  - var在同一个作用域内声明同一个变量后面会覆盖前面的
  - var：只有全局作用域和函数作用域概念，没有块级作用域的概念。但是会把{}内也假称为块作用域。
  -  var 存在变量提升，而 let，const（后面会提及）声明的变量却不存在变量提升

#### 16 重定向以后如何传参

#### 17 常见的网络攻击

参考https://blog.csdn.net/qq_37675827/article/details/77978505

- SQL注入

  - 就是通过把SQL命令插入到Web[表单](http://baike.baidu.com/view/296684.htm)递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
  - 比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到[SQL注入式攻击](http://baike.baidu.com/view/195362.htm)．  根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致 地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处 理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。

- XSS防御

  -  服务器对客户端的输入检测不严格 ，导致客户端输入的恶意JAVASCRIPT代码被植入到HTML代码中，这些JAVASCRIPT代码得以执行，实现一些特殊的目的.

  - XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。

    

- ***CSRF***

  -  跨站请求伪造，也被称成为“one click attack”或者session riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用

  - CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：
        攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。

  - CSRF攻击攻击原理及过程如下：

    ​    1. 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；

    ​    2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

    ​    3. 用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；

        4. 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；
            5. 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。** 

- XSS与CSRF区别
  - XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。

#### 18 js 基本数据类型

JS数据类型：JS的基本类型和引用类型有哪些呢？

  基本类型（单类型）：除Object。 String、Number、boolean、null、undefined。

  引用类型：object。里面包含的 function、Array、Date。

ES6 中新增了一种 Symbol 。这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。

 #### 19 如何判断js数据类型

**1.typeof**

**2.instanceof**

其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。

**3 constructor**

**4、Object.prototype.toString（这个是判断类型最准的方法）**
toString是Object原型对象上的一个方法，该方法默认返回其调用者的具体类型，更严格的讲，是 toString运行时this指向的对象类型, 返回的类型格式为[object,xxx]，xxx是具体的数据类型，其中包括：**String,Number,Boolean,Undefined,Null,Function,Date,Array,RegExp,Error,HTMLDocument,…** 基本上所有对象的类型都可以通过这个方法获取到。

#### 20 js作用链域

根据在内部函数可以访问外部函数变量的这种机制，用链式查找决定哪些数据能被内部函数访问。 
想要知道js怎么链式查找，就得先了解js的执行环境

执行环境（execution context）

每个函数运行时都会产生一个执行环境，而这个执行环境怎么表示呢？**js为每一个执行环境关联了一个变量对象。环境中定义的所有变量和函数都保存在这个对象中。** 

全局执行环境是最外围的执行环境，全局执行环境被认为是window对象，因此所有的全局变量和函数都作为window对象的属性和方法创建的。 
js的执行顺序是根据函数的调用来决定的，当一个函数被调用时，该函数环境的变量对象就被压入一个环境栈中。而在函数执行之后，栈将该函数的变量对象弹出，把控制权交给之前的执行环境变量对象。 

#### 21 js 继承

https://www.jianshu.com/p/a00a1488dd42

- 原型链继承 
- 构造继承
- 组合继承

#### 22 重排 重绘

当DOM元素影响了元素的几何属性（例如宽和高），浏览器需要重新计算元素的几何属性，同样其它元素的几何属性也会和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为“重排”。
完成重排后，浏览器会重新绘制受影响的部分到屏幕上中，该过程称为“重绘”。

- 重排发生的情况：

添加或删除可见的DOM元素。
元素位置改变。
元素的尺寸改变（包括：内外边距、边框厚度、宽度、高度等属性的改变）。
内容改变。
页面渲染器初始化。
浏览器窗口尺寸改变。

- 重绘发生的情况：

重绘发生在元素的可见的外观被改变，但并没有影响到布局的时候。比如，仅修改DOM元素的字体颜色（只有Repaint，因为不需要调整布局）

**重排必定会引发重绘，但重绘不一定会引发重排。**

#### 23 Node.js到底是用来做什么的

2009年发明出来的一种一个能够在服务器端运行JavaScript，并且可以开放源代码，以及跨平台运行JavaScript的一种运行环境。

它是一个**运行环境**，并不是其他的什么比如软件库，简而言之，和C#所需要的编译环境一样，Node.js就是JavaScript的编译环境，它存在的目的就是为了让JavaScript可以和其他的后端语言一样能够在浏览器上运行

#### 24 axios

axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征：

------

- 从浏览器中创建 XMLHttpRequest
- 从 node.js 发出 http 请求
- 支持 Promise API
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- 自动转换JSON数据
- 客户端支持防止 [CSRF/XSRF](http://baike.baidu.com/link?url=iUceAfgyfJOacUtjPgT4ifaSOxDULAc_MzcLEOTySflAn5iLlHfMGsZMtthBm5sK4y6skrSvJ1HOO2qKtV1ej_)

#### 25 懒加载

路由懒加载

![image-20200828113257460](C:\Users\qiaoba\AppData\Roaming\Typora\typora-user-images\image-20200828113257460.png)

 在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时

六、懒加载的最终实现方案

　　1、路由页面以及路由页面中的组件全都使用懒加载

　　优点：（1）最大化的实现随用随载

　　　　　（2）团队开发不会因为沟通问题造成资源的重复浪费　　　　

　　缺点：（1）当一个页面中嵌套多个组件时将发送多次的http请求，可能会造成网页显示过慢且渲染参差不齐的问题

　　2、路由页面使用懒加载， 而路由页面中的组件按需进行懒加载, 即如果组件不大且使用不太频繁, 直接在路由页面中导入组件, 如果组件使用较为频繁使用懒加载

　　优点：（1）能够减少页面中的http请求，页面显示效果好

　　缺点：（2）需要团队事先交流， 在框架中分别建立懒加载组件与非懒加载组件文件夹

　　3、路由页面使用懒加载，在不特别影响首页显示延迟的情况下，根页面合理导入复用组件，再结合方案2

　　优点：（1）合理解决首页延迟显示问题

　　　　　（2）能够最大化的减少http请求， 且做其他他路由界面的显示效果最佳

　　缺点：（1）还是需要团队交流，建立合理区分各种加载方式的组件文件夹

项目 使用第三种方案设计

#### 26 vuex是一个为vuejs的应用开发的状态管理模式

状态管理：就是把需要多个组件共享的变量全部存储在一个对象里。

vuex使用了单一状态树来管理应用层全部状态 

跟新的唯一方式 提交mutation

#### 27 vue-resource

vue-resource是vue中使用的请求网络数据的插件，这个插件是依赖于vue的，简单说就是用来调接口的

#### 28 https

https://www.cnblogs.com/sxiszero/p/11133747.html

HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer 或 Hypertext Transfer Protocol Secure，超文本传输安全协议），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https: URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。
众所周知，WEB服务存在http和https两种通信方式，http默认采用80作为通讯端口，对于传输采用不加密的方式；https默认采用443，对于传输的数据进行加密传输。目前主流的网站基本上开始默认采用HTTPS作为通信方式

- 对称加密

  对称加密算法的加密和解密都是用**同一个密钥**

  如果通信双方都各自持有同一个密钥，且没有别人知道，则两方的通信安全是可以被保证的（除非密钥被破解）。
  然而，最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，这个传输过程中密钥被别人劫持，之后他就能用密钥解开双方传输的任何内容。
  如果浏览器内部预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的。这样，浏览器只要预存好世界上所有HTTPS网站的密钥就可以了。显然，这样做是不现实的。
  怎么办？解决这个问题，我们就需要非对称加密。

![img](https://img2018.cnblogs.com/blog/611089/201907/611089-20190704172932212-1865243822.png)

- 非对称加密

  基于对称加密存在的问题，又有了非对称加密。非对称加密算法需要**一组密钥对**，分别是**公钥**和**私钥**，这两个密钥是成对出现的。**公钥加密的内容需要对应的私钥解密，私钥加密的内容需要对应的公钥解密**。私钥由服务器自己保存，**公钥发送给客户端**。客户端拿到公钥后可以对请求进行加密后发送给服务端，这时候就算中间被截获，没有私钥也无法解密发送的内容，这样确保了**客户端发送到服务端数据的安全**。

![img](https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173037022-575825113.png)

过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程：

1. 某网站拥有用于非对称加密的公钥A1、私钥A2；浏览器拥有用于非对称加密的公钥B1、私钥B2。
2. 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。
3. 浏览器把公钥B1明文传输给服务器。
4. 之后浏览器向服务器传输的所有东西都用公钥A1加密，服务器收到后用私钥A2解密。由于只有服务器拥有私钥A2进行解密，所以能保证这条数据的安全。
5. 服务器向浏览器传输的所有东西都用公钥B1加密，浏览器收到后用私钥B2解密。同上也可以保证这条数据的安全。

可见确实可行。抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心。而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？

- 中间人攻击

  ![img](https://img2018.cnblogs.com/blog/611089/201907/611089-20190704173100652-22100951.png)

中间人的确无法得到浏览器生成的对称密钥X，这个密钥本身被公钥A1加密，只有服务器才能用私钥A2进行解密。然而中间人却完全不需要拿到私钥A2就能劫持信息，请看：

1. 某网站拥有用于非对称加密的公钥A1、私钥A2。
2. 浏览器向网站服务器请求，服务器把公钥A1明文传输给浏览器。
3. 中间人劫持到公钥A1，保存下来，把数据包中的公钥A1替换成自己伪造的公钥B1（它当然也拥有公钥B1对应的私钥B2）。
4. 浏览器随机生成一个用于对称加密的密钥X，用公钥B1（浏览器不知道公钥被替换了）加密后传给服务器。
5. 中间人劫持后用私钥B2解密得到密钥X，再用公钥A1加密后传给服务器。
6. 服务器拿到后用私钥A2解密得到密钥X。

这样在双方都不会发现异常的情况下，中间人得到了对称密钥X。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决这个问题：如何证明浏览器收到的公钥一定是该网站的公钥？